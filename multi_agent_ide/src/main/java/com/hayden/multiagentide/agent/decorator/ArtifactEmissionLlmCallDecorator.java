package com.hayden.multiagentide.agent.decorator;

import com.embabel.agent.api.common.nested.TemplateOperations;
import com.embabel.agent.api.tool.Tool;
import com.google.common.collect.Lists;
import com.hayden.multiagentide.artifacts.ArtifactService;
import com.hayden.multiagentide.artifacts.ExecutionScopeService;
import com.hayden.multiagentide.artifacts.PromptContributionArtifactListener;
import com.hayden.multiagentide.tool.ToolAbstraction;
import com.hayden.multiagentidelib.artifact.PromptTemplateVersion;
import com.hayden.multiagentidelib.prompt.PromptContext;
import com.hayden.multiagentidelib.prompt.PromptContributor;
import com.hayden.multiagentidelib.prompt.PromptContributorAdapter;
import com.hayden.acp_cdc_ai.acp.events.Artifact;
import com.hayden.acp_cdc_ai.acp.events.ArtifactKey;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Decorator that emits artifact events for LLM interactions.
 * <p>
 * This decorator hooks into the LLM call pipeline to:
 * - Emit rendered prompt artifacts before LLM calls
 * - Could be extended to emit response artifacts after LLM calls
 * - Emit tool call artifacts during execution
 * <p>
 * Artifacts are added to the execution's AgentExecutionArtifacts group.
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class ArtifactEmissionLlmCallDecorator implements LlmCallDecorator {

    private final ExecutionScopeService executionScopeService;

    private final PromptContributionArtifactListener promptContributionArtifactListener;
    
    private final ArtifactService artifactService;

    @Override
    public int order() {
        return 10_000;
    }

    @Override
    public LlmCallContext decorate(LlmCallContext context) {
        if (context == null || context.promptContext() == null) {
            return context;
        }

        PromptContext promptContext = context.promptContext();
        TemplateOperations templateOps = context.templateOperations();
        emitRenderedPrompt(promptContext, templateOps, context);
        return context;
    }

    /**
     * Retrieves an existing artifact by hash or creates a new one.
     * This method recursively processes all child artifacts as well.
     *
     * @param artifactBuilder A supplier that creates the artifact (will only be called if not found in DB)
     * @param hash The content hash of the artifact
     * @param artifactKey The artifact key to use for this execution context
     * @return The artifact (either retrieved or newly created)
     */
    private Artifact getOrCreateArtifact(
            Supplier<Artifact> artifactBuilder,
            String hash,
            ArtifactKey artifactKey
    ) {
        if (hash == null || hash.isEmpty()) {
            return artifactBuilder.get();
        }

        // Check if artifact with this hash already exists
        Optional<Artifact> existingArtifact = artifactService.decorateDuplicate(hash, artifactKey);

        if (existingArtifact.isPresent()) {
            @SuppressWarnings("unchecked")
            Artifact existing = existingArtifact.get();
            
            log.debug("Reusing existing artifact with hash: {} and type: {}",
                    hash, existing.artifactType());
            return existing;
        }

        // Create new artifact
        Artifact newArtifact = artifactBuilder.get();
        log.debug("Created new artifact with hash: {} and type: {}", 
                hash, newArtifact.artifactType());
        return newArtifact;
    }

    /**
     * Emits a rendered prompt artifact.
     * First checks if an artifact with the same hash exists in the database.
     * If found, reuses the existing artifact; otherwise, creates a new one.
     * Recursively checks all child artifacts as well.
     */
    private void emitRenderedPrompt(
            PromptContext promptContext,
            TemplateOperations templateOps,
            LlmCallContext llmCallContext
    ) {
        try {
            // Get the artifact key for the agent execution group
            ArtifactKey groupKey = promptContext.currentRequest().artifactKey();

            // Create child key for this prompt
            ArtifactKey promptKey = groupKey.createChild();

            // Extract rendered text from template operations or prompt context
            String renderedText = extractRenderedText(templateOps, llmCallContext);

            if (renderedText == null)
                return;

            // Compute hash of the rendered text
            String hash = promptContext.hashContext().hash(renderedText);

            // Build the prompt artifact with all children, checking hash for each
            Artifact promptArtifact = getOrCreateArtifact(
                    () -> buildRenderedPromptArtifact(promptContext, llmCallContext, promptKey, renderedText, hash),
                    hash,
                    promptKey
            );

            // Emit artifact
            executionScopeService.emitArtifact(promptArtifact, groupKey);

            log.debug("Emitted rendered prompt artifact: {} with hash: {} for agent type: {}",
                    promptKey, hash, promptContext.agentType());

        } catch (Exception e) {
            log.error("Failed to emit rendered prompt artifact", e);
        }
    }

    /**
     * Builds a RenderedPromptArtifact with all its children, checking hash for each child.
     */
    private Artifact.RenderedPromptArtifact buildRenderedPromptArtifact(
            PromptContext promptContext,
            LlmCallContext llmCallContext,
            ArtifactKey promptKey,
            String renderedText,
            String hash
    ) {
        ArtifactKey promptTemplateVersionKey = promptKey.createChild();

        var bareTemplate = llmCallContext.op().agentPlatform().getPlatformServices().getTemplateRenderer().load(promptContext.templateName());

        // Build PromptTemplateVersion (checking hash)
        Artifact templateVersion = getOrCreateArtifact(
                () -> PromptTemplateVersion.builder()
                        .templateStaticId(promptContext.templateName())
                        .templateArtifactKey(promptTemplateVersionKey)
                        .hash(promptContext.hashContext().hash(bareTemplate))
                        .templateText(bareTemplate)
                        .lastUpdatedAt(Instant.now())
                        .build(),
                null, // TODO: compute proper hash for template version
                promptTemplateVersionKey
        );

        // Build PromptArgsArtifact (checking hash)
        String argsHash = promptContext.hashContext().hashMap(llmCallContext.templateArgs());
        Artifact argsArtifact = getOrCreateArtifact(
                () -> Artifact.PromptArgsArtifact.builder()
                        .metadata(new HashMap<>())
                        .artifactKey(promptKey.createChild())
                        .args(llmCallContext.templateArgs())
                        .hash(argsHash)
                        .metadata(Map.of(
                                "argCount", String.valueOf(llmCallContext.templateArgs().size())
                        ))
                        .build(),
                argsHash,
                promptKey.createChild()
        );

        // Build prompt contributor artifacts (checking hash for each)
        List<Artifact> contributorArtifacts = promptContext.promptContributors()
                .stream()
                .flatMap(context -> {
                    if (context instanceof PromptContributorAdapter adapter) {
                        return Stream.of(adapter.getContributor());
                    }
                    log.error("Found prompt element {} that was unknown template and could not add artifact or versioning - {}: {}.",
                            context.getPromptContributionLocation(), promptContext.agentType(), promptContext.currentContextId());
                    return Stream.empty();
                })
                .map(pc -> buildRenderedPromptContributor(promptContext, pc, promptKey.createChild()))
                .collect(Collectors.toCollection(ArrayList::new));

        // Build tool prompt artifacts (tool descriptions provided to LLM)
        List<Artifact> toolPromptArtifacts = buildToolPromptArtifacts(llmCallContext, promptKey);

        // Combine all children
        List<Artifact> allChildren = new ArrayList<>();
        allChildren.add(templateVersion);
        allChildren.add(argsArtifact);
        allChildren.addAll(contributorArtifacts);
        allChildren.addAll(toolPromptArtifacts);

        return Artifact.RenderedPromptArtifact.builder()
                .artifactKey(promptKey)
                .renderedText(renderedText)
                .hash(hash)
                .promptName(promptContext.templateName())
                .metadata(Map.of(
                        "agentType", promptContext.agentType().toString(),
                        "templateName", promptContext.templateName()
                ))
                .children(allChildren)
                .build();
    }

    /**
     * Creates tool prompt artifacts from the LlmCallContext.
     * These artifacts represent the tool descriptions that are provided to the LLM
     * as part of the prompt context (not tool call results).
     */
    private List<Artifact> buildToolPromptArtifacts(
            LlmCallContext llmCallContext,
            ArtifactKey parentKey
    ) {
        if (llmCallContext == null || llmCallContext.tcc() == null || llmCallContext.tcc().tools().isEmpty()) {
            return new ArrayList<>();
        }

        List<Artifact> artifacts = new ArrayList<>();

        // Build tool prompt artifacts
        List<Artifact> toolArtifacts = llmCallContext.tcc().tools()
                .stream()
                .flatMap(ta -> extractToolDescriptions(ta).stream())
                .map(td -> buildToolPrompt(td, parentKey.createChild(), llmCallContext.promptContext()))
                .collect(Collectors.toCollection(ArrayList::new));
        artifacts.addAll(toolArtifacts);

        // Build skill prompt artifacts
        List<Artifact> skillArtifacts = llmCallContext.tcc().tools()
                .stream()
                .flatMap(ta -> extractSkillDescriptions(ta).stream())
                .map(sd -> buildSkillPrompt(sd, parentKey.createChild(), llmCallContext.promptContext()))
                .collect(Collectors.toCollection(ArrayList::new));
        artifacts.addAll(skillArtifacts);

        return artifacts;
    }
    
    /**
     * Extracts tool descriptions from a ToolAbstraction.
     * Handles all sealed subtypes of ToolAbstraction.
     */
    private List<ToolDescription> extractToolDescriptions(ToolAbstraction toolAbstraction) {
        return switch (toolAbstraction) {
            case ToolAbstraction.SpringToolCallback stc -> {
                var def = stc.toolCallback().getToolDefinition();
                yield List.of(new ToolDescription(
                        def.name(),
                        def.description(),
                        def.inputSchema()
                ));
            }
            case ToolAbstraction.SpringToolCallbackProvider stcp -> {
                var callbacks = stcp.toolCallbackProvider().getToolCallbacks();
                yield Arrays.stream(callbacks)
                        .map(tc -> {
                            var def = tc.getToolDefinition();
                            return new ToolDescription(
                                    def.name(),
                                    def.description(),
                                    def.inputSchema()
                            );
                        })
                        .toList();
            }
            case ToolAbstraction.EmbabelTool et -> {
                var def = et.tool().getDefinition();
                yield List.of(new ToolDescription(
                        def.getName(),
                        def.getDescription(),
                        def.getInputSchema().toJsonSchema()
                ));
            }
            case ToolAbstraction.EmbabelToolObject eto -> {
                // ToolObject contains objects with @LlmTool annotated methods
                // We extract tools using Tool.safelyFromInstance
                var tools = eto.toolObject().getObjects().stream()
                        .flatMap(obj -> Tool.safelyFromInstance(obj).stream())
                        .toList();
                yield tools.stream()
                        .map(t -> {
                            var def = t.getDefinition();
                            return new ToolDescription(
                                    def.getName(),
                                    def.getDescription(),
                                    def.getInputSchema().toJsonSchema()
                            );
                        })
                        .toList();
            }
            case ToolAbstraction.EmbabelToolGroup etg -> {
                yield etg.toolGroup().getToolCallbacks().stream()
                        .map(tc -> {
                            var def = tc.getToolDefinition();
                            return new ToolDescription(
                                    def.name(),
                                    def.description(),
                                    def.inputSchema()
                            );
                        })
                        .toList();
            }
            case ToolAbstraction.EmbabelToolGroupRequirement etgr -> {
                // ToolGroupRequirement is just a role reference, not actual tools
                // The actual tools are resolved at runtime by ToolGroupResolver
                log.debug("ToolGroupRequirement '{}' cannot be resolved to tool descriptions without ToolGroupResolver",
                        etgr.requirement().getRole());
                yield List.of();
            }
            case ToolAbstraction.ToolGroupStrings tgs -> {
                // ToolGroupStrings are string references, not actual tools
                log.debug("ToolGroupStrings {} cannot be resolved to tool descriptions without ToolGroupResolver",
                        tgs.toolGroups());
                yield List.of();
            }
            case ToolAbstraction.SkillReference skillReference -> {
                yield List.of();
            }
        };
    }
    
    /**
     * Internal record for holding extracted tool description data.
     */
    private record ToolDescription(String name, String description, String inputSchema) {}

    /**
     * Internal record for holding extracted skill description data.
     */
    private record SkillDescription(String name, String description) {}

    /**
     * Extracts skill descriptions from a ToolAbstraction.
     * Only handles SkillReference type, returns empty list for other types.
     */
    private List<SkillDescription> extractSkillDescriptions(ToolAbstraction toolAbstraction) {
        return switch (toolAbstraction) {
            case ToolAbstraction.SkillReference skillReference -> {
                var skillDecorator = skillReference.loadedSkills();
                if (skillDecorator != null && skillDecorator.getSkill() != null) {
                    var skills = skillDecorator.getSkill();
                    yield List.of(new SkillDescription(
                            skills.getName(),
                            skills.getDescription()
                    ));
                }
                yield List.of();
            }
            default -> List.of();
        };
    }
    
    /**
     * Creates a single tool prompt artifact with hash checking.
     */
    private Artifact buildToolPrompt(
            ToolDescription toolDescription,
            ArtifactKey artifactKey,
            PromptContext promptContext
    ) {
        // Build the full tool description text for hashing
        String fullDescription = buildToolDescriptionText(toolDescription);
        String hash = promptContext.hashContext().hash(fullDescription);
        
        return getOrCreateArtifact(
                () -> Artifact.ToolPrompt.builder()
                        .artifactKey(artifactKey)
                        .toolCallName(toolDescription.name())
                        .toolDescription(fullDescription)
                        .hash(hash)
                        .metadata(Map.of(
                                "toolName", toolDescription.name(),
                                "hasInputSchema", String.valueOf(toolDescription.inputSchema() != null && !toolDescription.inputSchema().isEmpty())
                        ))
                        .children(new ArrayList<>())
                        .build(),
                hash,
                artifactKey
        );
    }
    
    /**
     * Builds a complete tool description text including name, description, and input schema.
     */
    private String buildToolDescriptionText(ToolDescription toolDescription) {
        StringBuilder sb = new StringBuilder();
        sb.append("Tool: ").append(toolDescription.name()).append("\n");
        if (toolDescription.description() != null && !toolDescription.description().isEmpty()) {
            sb.append("Description: ").append(toolDescription.description()).append("\n");
        }
        if (toolDescription.inputSchema() != null && !toolDescription.inputSchema().isEmpty()) {
            sb.append("Input Schema: ").append(toolDescription.inputSchema()).append("\n");
        }
        return sb.toString();
    }

    /**
     * Creates a single skill prompt artifact with hash checking.
     */
    private Artifact buildSkillPrompt(
            SkillDescription skillDescription,
            ArtifactKey artifactKey,
            PromptContext promptContext
    ) {
        // Build the full skill description text for hashing
        String fullDescription = buildSkillDescriptionText(skillDescription);
        String hash = promptContext.hashContext().hash(fullDescription);

        return getOrCreateArtifact(
                () -> Artifact.SkillPrompt.builder()
                        .artifactKey(artifactKey)
                        .skillName(skillDescription.name())
                        .skillDescription(fullDescription)
                        .hash(hash)
                        .metadata(Map.of(
                                "skillName", skillDescription.name() != null ? skillDescription.name() : ""
                        ))
                        .children(new ArrayList<>())
                        .build(),
                hash,
                artifactKey
        );
    }

    /**
     * Builds a complete skill description text including name and description.
     */
    private String buildSkillDescriptionText(SkillDescription skillDescription) {
        StringBuilder sb = new StringBuilder();
        sb.append("Skill: ").append(skillDescription.name()).append("\n");
        if (skillDescription.description() != null && !skillDescription.description().isEmpty()) {
            sb.append("Description: ").append(skillDescription.description()).append("\n");
        }
        return sb.toString();
    }

    /**
     * Extracts the rendered text from template operations or builds it from prompt context.
     */
    private String extractRenderedText(TemplateOperations templateOps, LlmCallContext llmCallContext) {
        if (templateOps == null) {
            return null;
        }

        return templateOps.generateText(llmCallContext.templateArgs());
    }


    /**
     * Builds a RenderedPromptArtifact for a prompt contributor, checking hash for all children.
     */
    private Artifact buildRenderedPromptContributor(
            PromptContext promptContext,
            PromptContributor pc,
            ArtifactKey key
    ) {
        var renderedText = pc.contribute(promptContext);
        var hash = promptContext.hashContext().hash(renderedText);
        
        // Check if this contributor artifact already exists
        return getOrCreateArtifact(
                () -> {
                    var promptTemplateVersionKey = key.createChild();
                    
                    // Build contribution template artifact (checking hash)
                    var contributionTemplate = buildPromptContributorArtifact(promptContext, pc, promptTemplateVersionKey.createChild());
                    
                    // Build contribution args artifact (checking hash)
                    var contributionArgs = buildPromptContributorTemplate(promptContext, pc, promptTemplateVersionKey.createChild());

                    return Artifact.RenderedPromptArtifact.builder()
                            .artifactKey(key)
                            .renderedText(renderedText)
                            .hash(hash)
                            .metadata(Map.of(
                                    "agentType", promptContext.agentType().toString(),
                                    "templateName", promptContext.templateName()
                            ))
                            .children(Lists.newArrayList(contributionTemplate, contributionArgs))
                            .promptName(pc.name())
                            .build();
                },
                hash,
                key
        );
    }

    /**
     * Builds a PromptContributionTemplate artifact, checking hash for reuse.
     */
    private Artifact buildPromptContributorArtifact(
            PromptContext context,
            PromptContributor promptContributor,
            ArtifactKey key
    ) {
        var promptContributorName = promptContributor.name();
        var contributedText = promptContributor.template();
        var hash = context.hashContext().hash(contributedText);

        return getOrCreateArtifact(
                () -> Artifact.PromptContributionTemplate.builder()
                        .artifactKey(key)
                        .contributorName(promptContributorName)
                        .templateText(contributedText)
                        .hash(hash)
                        .metadata(Map.of(
                                "agentType", context.agentType() != null ? context.agentType().name() : "UNKNOWN"
                        ))
                        .children(Lists.newArrayList())
                        .build(),
                hash,
                key
        );
    }

    /**
     * Builds a PromptArgsArtifact for a prompt contributor, checking hash for reuse.
     */
    private Artifact buildPromptContributorTemplate(
            PromptContext context,
            PromptContributor promptContributor,
            ArtifactKey key
    ) {
        var hash = context.hashContext().hashMap(promptContributor.args());
        
        return getOrCreateArtifact(
                () -> Artifact.PromptArgsArtifact.builder()
                        .hash(hash)
                        .children(Lists.newArrayList())
                        .artifactKey(key)
                        .args(promptContributor.args())
                        .metadata(Map.of(
                                "argCount", String.valueOf(promptContributor.args().size()),
                                "promptContributorName", promptContributor.name(),
                                "agentType", context.agentType() != null ? context.agentType().name() : "UNKNOWN"
                        ))
                        .build(),
                hash,
                key
        );
    }
}

